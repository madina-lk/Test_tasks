1. На языке Python реализовать алгоритм (функцию) определения четности целого числа, 
который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. 
Объяснить плюсы и минусы обеих реализаций.

Python example:
    def isEven(value):return value%2==0

Ответ:

def isEven_1(value):
    return value % 2 == 0

def isEven_2(value):
    return value & 1 == 0

if __name__ == '__main__':
    import timeit

    print(timeit.timeit('isEven_1(8)', setup="from __main__ import isEven_1"))
    print(timeit.timeit('isEven_2(8)', setup="from __main__ import isEven_2"))

Оценивая обе реализации на скорость выполнения компилятором Python 3.8, можно увидеть, что тестируя 
обе функции, можно заметить, что числа небольшого диапазона значений, как правило < 1e9, выполняются 
первым методом быстрее в силу улучшенной оптимизации арифметических операций. 
Например, время выполнения timeit() для isEven_1(4)= 0.112242599, а isEven_2(4)= 0.151957545, 
в то время как t выполнения для больших чисел, isEven_1(445363463633455666666)= 0.166288008, а 
isEven_2(445363463633455666666)= 0.145405952. 
Таким образом, при имеющемся раскладе, при использовании больших чисел эффективнее использовать 
побитовый оператор.
При тестировании этих функций на компиляторе Python 2.7 время выполнения второй функции при любом числе 
будет меньше времени выполнения первой функции. 
Следовательно, выбор реализации должен исходить из размера обрабатываемого числа и выбранного компилятора.

2. На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. 
Объяснить плюсы и минусы каждой реализации.

Реализовано три класса: с использованием numpy и deque
1. numpy
#!/usr/bin/python
# -*- coding: ascii -*-

import numpy

class RingBuffer:
    def __init__(self, size):
        """
                Конструктор класса
                :param size: размер массива numpy
                :type size: int
                :param data: массив, заполненный нулями
                :type data: float
                :param index:
                :type index: int
        """
        self.data = numpy.zeros(size, dtype='f')
        self.index = 0
        self.size = 0

    def append(self, val):
        """
        Добавление значений в буфер
        :param val: добавляемое значение
        :type val: float
        :return: None
        """
        self.data = numpy.roll(self.data, 1)
        self.data[0] = val

        self.size += 1

    def get(self):
        """ Возвращает данные в порядке поступления в буфер
        :return: array
        :rtype: float
        """
        idx = (self.index + numpy.arange(self.data.size)) %self.data.size
        return self.data[idx]

def ringbuff_numpy_test():
    ringlen = 100000
    ringbuff = RingBuffer(ringlen)
    for i in range(50):
        ringbuff.append(20.0)
    return ringbuff.get()

import timeit

print(timeit.timeit('ringbuff_numpy_test()', setup="from task_2 import ringbuff_numpy_test"))

Плюсы и минусы:
Реализация циклического буфера с помощью Numpy основывается на циклическом сдвиг элементов вдоль выбранного направления
с помощью метода roll(). Данный метод прост в реализациии и превосходит аналогичные методы по времени (например, с помощью дека)
Минусы данной реализации в том, что если нужен растущий массив, придется удваивать его размер каждый раз, 
когда требуется изменение размера в отличие от реализации циклического массива ниже.

2. Списком
#!/usr/bin/python
# -*- coding: ascii -*-

class RingBuffer:
    def __init__(self, size, data=[]):
        """
        Конструктор
        :param size: размер массива
        :param data: список
        """
        self.index = 0
        self.size = size
        self.data = list(data)[-size:]

    def append(self, val):
        """
        Добавление элементов
        :param value: добавляемый элемент
        :return: None
        """
        if len(self.data) == self.size:
            self.data[self.index] = val
        else:
            self.data.append(val)
        self.index = (self.index + 1) % self.size

    def get(self, key):
        """
        Получение элемента по индексу относительно текущего индекса
        :param key: 
        :return: список
        """
        if len(self.data) == self.size:
            return self.data[(key + self.index) % self.size]
        else:
            return self.data[key]

Плюс реализации списком хорош тем, что списки Python допускают отрицательные индексы, и (-1), например, 
не вернет ожидаемое значение после заполнения циклического буфера, поскольку «последнее» добавление в список 
оказывается внутри списка по циклу.
Минусы в том, что по времени данный алгоритм уступает по времени массиву на основе Numpy.

4. На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. 
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). 
Объяснить почему вы считаете, что функция соответствует заданным критериям.

Оптимальная по времени сортировка зависит от выбранного случая. Универсальной сортировки с постоянной по времени 
сложностью для лучшего, среднего и худшего случая не существует.
Если взять, например, используюмую Python по умолчанию быструю сортировку, можно видеть, что быстрая сортировка 
имеет в среднем O(n log n) обменов, а при худшеем раскладе – O(n^2) - если массив уже отсортирован, или элементы равны.
Cортировки вставками, пузырьком и выбором имеют среднюю сложность O(n^2) и используются в особых случаях.
Сортировка слиянием и кучей, являются хорошими алгоритмами и имеют среднюю сложность O(nlog(n)).
При выборе линейных алгоритмов сложность будет O(n).
Т.е. если рассматривать средний и наилучший случай, то подойдет быстрая сортировка, а если худший случай - то слиянием.
Таким образом, птимальность алгоритма тесно зависит от типа списков/массивов, которые вы собираетесь сортировать, 
и даже от модели ЭВМ.
